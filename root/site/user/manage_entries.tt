[% page.load_scripts_at_top = 1 %]
	
<div id="div_table"></div>
<script type="text/javascript">
YUI().use( "datasource-io", "datasource-jsonschema", "datatable-datasource", function (Y) {
// -------------------------
//  Define a few DataTable helper methods
//    NOTE: These only work with the 3.5.0PR release of DataTable  
// -------------------------

	/**
	 Method to take an existing TD or TR Node element as input "target" and scan 
	 the dataset (ModelList) for the underlying data record (a Model).
	 
	 @method getRecord
	 @param target {Node} Either a TR or TD Node
	 @returns {Model} Data record or false (or -1 if not found)
	 **/
	//FIXME: if target is numeric or string, not working yet ... Node only works
	Y.DataTable.prototype.getRecord = function( target ) {
		var rs = this.get('data')
			tag = target.get('tagName').toLowerCase();
			
		var row = ( tag === 'td' ) ? target.ancestor() : ( tag === 'tr' ) ? target : null;
		if ( !row ) return false;
		
		if ( Y.Lang.isNumber(row) ) 		// assume row is rowindex
			return rs.item(row) || false;
			
		else if ( row instanceof Y.Node || Y.Lang.isString(row) ) {
			var crow = ( Y.Lang.isString(row) ) ? row : row.get('id');	// matches based on DOM id
			var rec = -1;
			rs.some( function(item) {
				if ( item.get('clientId') === crow ) {
					rec = item;
					return true;
				}
			});
			return rec;
		}				
		return false;
	}


	/**
	 Helper method to return the column's key property associated with the current TD.
	 Uses DataTable's current method of identifying a class on TD as "yui3-datatable-col-XXX" 
	 where XXX is the column 'key' (or 'name')
	 
	 @method getDTColumnKey
	 @param tdTarget {Node} The TD cell to return column key to
	 @returns ckey {String} column key name		  
	 **/
	Y.DataTable.prototype.getCellColumnKey = function( tdTarget ) {
		var DT_COL_CLASS = this.getClassName('col');
		var regex = new RegExp( DT_COL_CLASS+'-(.*)'),		// currently creates /yui3-datatable-col-(.*) to grab column key
			tdclass = tdTarget.get('className').split(" "),
			ckey    = -1;
		
	//
	//  Scan through the TD class(es), checking for a match
	//	
		Y.Array.some( tdclass, function(item){
			var mitem = item.match( regex );
			if ( mitem && mitem[1] ) {
				ckey = mitem[1].replace(/^\s+|\s+$/g,"");	// trim all spaces
				return true;
			}
		}); 
		return ckey || false;
	}

/*  https://gist.github.com/1707631  
  
	Y.DataTable.prototype.getCellColumnKey = function (node) {
	    var classRE = new RegExp('\b' + this.getClassName('col') + '-(\W+)'),
	        name, column;
	
	    node = node.ancestor('.' + this.getClassName('cell'), true);
	
	    if (node) {
	        name = (node.get('className').match(classRE) || [])[1];
	
	        column = name && this.getColumn(name);
	    }
	
	    return column && column.key;
	};
*/


	/**
	 Method to scan the "columns" Array for the target and return the requested column.
	 The requested "target" can be either of ;
	 	a column index, 
	 	or a TD Node, 
	 	or a column "key", column "name" or "_yuid" (in that order). 
	 
	 @method getColumn
	 @param target {Number | Node | String} Either the column index, the TD node or a column ID
	 @returns {Object} Column
	 **/
	Y.DataTable.prototype.getColumn = function( target ) {
		var cs = this.get('columns'),
			ckey = null;
		
		if (Y.Lang.isNumber(target) )
			return cs[target];  //return cs.keys[col];
			
		else if ( Y.Lang.isString(target) || target instanceof Y.Node ) {	// check for 'key' or then 'name', finally '_yuid'
		
			ckey = ( target instanceof Y.Node ) ? ckey = this.getCellColumnKey( target ) : ckey;
		
			col = ( ckey ) ? ckey : target;
		
		// Check if a column "key"
			var cm = -1;
			Y.Array.some( cs, function(citem) {
				if ( citem['key'] === col ) {
					cm = citem;
					return true;
				}
			});
			if ( cm !== -1) return cm;	// found one, bail !!

		// If not found, Check if a column "name"
			Y.Array.some( cs, function(citem) {
				if ( citem.name === col ) {
					cm = citem;
					return true;
				}
			});
			if ( cm!==-1 ) return cm;

		// If not found, Check if a column "_yui" something
			Y.Array.some( cs, function(citem) {
				if ( citem._yuid === col ) {
					cm = citem;
					return true;
				}
			});
			return cm;

		} else 
			return false;
	}
	
    var fmtPublished = function(o) {
	    var published = o.value;   						
		  return o.value == 1 ?
           "yes"        :
           "no";
	  }

	  var fmtBlank = function(o) {
		  var fclass = o.column.className || null;
		  if (fclass) 
			  o.className += ' '+fclass;
		  o.value = ' ';
   	}		
    
    var cols = [ 
		  {key:"entryid", label:'ID'}, 
		  {key:"title", label:"Title"}, 
		  {key:"created_at", label:'Created At'}, 
		  {key:"published", label:'Published'},
      {key:"reply_count", label:'Replies'},
      { name:'edit',   	 label:'- Edit -',   	formatter: fmtBlank, className:'align-center cell-edit' },	
		  { name:'delete',   	 label:'- Delete -',   	formatter: fmtBlank, className:'align-center cell-delete' }
      
    ];
		
    var ds = new Y.DataSource.IO( { 
        source:"[% c.uri_for_action('/user/manage_entries', [ c.user.name ] ) %]",
        ioConfig: {
          headers: {
            'Accept': 'application/json'
          }
        }
        
    })
        .plug(Y.Plugin.DataSourceJSONSchema, {
            schema: {
                resultListLocator: "data_table",
                resultFields: [ "entryid", "title", "created_at", "published", "reply_count" ]
            }
        });
		
    var dt = new Y.DataTable({
    	columns: 	cols, 
    	caption:	"Entries"
    }).plug(
    	Y.Plugin.DataTableDataSource, {
    		datasource:	ds, 
      	initialRequest:""
    	});
		

   ds.after("response", function() {
        dt.render("#div_table")}
	 ); 
 
   var editorPanel = new Y.Panel({
        srcNode : '#idPanel',
        width   : 320,
    	xy 		: [ 750, 170 ],	
    	visible : false,
        render  : true,
        zIndex  : 10,
        plugins : [Y.Plugin.Drag], 
		buttons: [
		        {
		            value  : 'Save',
		            section: Y.WidgetStdMod.FOOTER,
		            action : function (e) {
		                if (e) e.preventDefault();
		             	saveFormData();
		                this.hide();
		            }
		        },
		        {
		            value  : 'Cancel',
		            section: Y.WidgetStdMod.FOOTER,
		            action : function (e) {
		                e.preventDefault();
		                this.hide();
		            }
		        }
	    ],
	    on : {
	    	'render' : function() { 
	    				   Y.one("#main").show();   // render the "main" page elements, 
	    			   } 
	   	}
    });

    //-----------------
	//  Function to save the FORM data, based on current values.
	//  Define a mapping object to help us figure out how to apply INPUT[name=xxx] to what 
	//    column of each record.
	//  Uses the setting of FORM hidden value "frmInsertFlag" to determine if this is a new
	//   record or if we are saving an existing record.  
	//  If existing, the record "clientId" is saved in FORM hidden value "frmRecord"
    //-----------------
   	var saveFormData = function() {
		var theForm = document.forms[0],
			rec_id 	= theForm.frmRecord.value,	// if INSERT, this is disregarded ...
			newData = {},
			raw_value  = 0,
			data_value = 0;
	//
	//  Define a mapping between the INPUT 'name' settings and the record "key" names ...
	//    also, define a parser on a few numeric items
	//		
		var record_map = [
			{ field:'entryid',    ckey:'entryid', parser: parseInt },	
			{ field:'title',  ckey:'title'},
			{ field:'published',  ckey:'created_at'},
			{ field:'reply_count', ckey:'reply_count', parser: parseInt }
		];


	//
	//  Run through the "record_map" FORM variables, inserting data values into "newData"
	//   that will serve as the data object for DataTable
	//	
		Y.Array.each( record_map, function(item){
			raw_value  = theForm[item.field].value;
			data_value = ( item.parser && Y.Lang.isFunction(item.parser) ) ? item.parser.call(this,raw_value)  : raw_value ;
			newData[ item.ckey ] = data_value;
		});

	//
	//  Now insert the "newData" object into DataTable's data, 
	//    check frmInsertFlag for whether it is "new" or "updated" data 
	//
		if ( parseInt( theForm.frmInsertFlag.value ) === 0 ) 

			dt.modifyRow( rec_id, newData );

		else

			dt.addRow( newData );

    }
   
  // trap an ENTER key on the form, save the data ...
	editorPanel.get('srcNode').on('key', function() {  
		saveFormData();
		editorPanel.hide();
	}, 'enter');	   
   
    //
    //  Define DEFAULT data for a "New" inserted row
    //
	var default_data = {
	  	entryid : 0,
	  	title : 'New Entry', 
	  	body : ' ',
      published : 0,
     	record : 0,
	  	insert : 1
   	};
   
  var showDT_Dialog = function( record, xy, insert_obj ) {
		var thePanel, DialogTMPL, body_html, header_html;

	//
	//  Grab the dialog internal content from the <script> template
	//
    	DialogTMPL = Y.one("#dialog-template").getContent();
    	thePanel = editorPanel;

		if ( !insert_obj ) {	// we are EDITING and existing row ...
		//
		//  Define the substitution objects to fill in the INPUT default values
		//
			var form_data = {
				entryid : 	record.get('entryid'),
				title :	record.get('title'),
				published :	record.get('published'),
				record :	record.get('entryid'),
				insert :	0
			}

			xy[0] += 50;	// offset the dialog a tinch, from the Edit TD ...

			header_html = 'Editing Row No. '  + (myDT.get('data').indexOf(record)+1);
			body_html = Y.Lang.sub( DialogTMPL, form_data );

		} else {	//  we are INSERTING a new row ...

			insertFlag = true;   // used 
			xy = default_dialog_xy;
			header_html = 'Inserting NEW Row';
			body_html = Y.Lang.sub( DialogTMPL, insert_obj );

		}

	//
	//	Fill the Panel content, position it and display it
	//	
		thePanel.set( 'xy', xy );
  		thePanel.set( 'headerContent', header_html );  
		thePanel.set( 'bodyContent', body_html );
		thePanel.show();
   	} 
  
// Button click handler for the "Insert New Row" button
	new Y.Button({srcNode:"#btnInsert"}).on("click",function() {
		editorPanel.hide();
		showDT_Dialog( 0, 0, default_data );
	});
     

});

</script>
